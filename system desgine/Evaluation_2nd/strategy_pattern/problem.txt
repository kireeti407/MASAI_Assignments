Requirements:

Strategy Interface:
Define an interface IPaymentStrategy with two methods:
pay(amount: number): void: Processes the payment and logs the result.
validateDetails(details: object): boolean: Validates the payment details provided by the user.
Concrete Strategies:
Implement at least three concrete strategies:
CreditCardPayment:
validateDetails: Must check for cardNumber, expiryDate, and cvv in the details object.
pay: Applies a 1.5% processing fee to the amount and logs a confirmation message.
PayPalPayment:
validateDetails: Must check for a valid email in the details object.
pay: Applies a 2.5% processing fee and logs a confirmation message.
CryptoPayment:
validateDetails: Must check for a walletAddress.
pay: Applies a fixed network fee of â‚¹50 and logs a confirmation message.
Context Class:
Create a PaymentProcessor context class.
It should hold a reference to an IPaymentStrategy object.
It needs a method setStrategy(strategy: IPaymentStrategy) to allow the client to change the payment method at runtime.
It needs a method processPayment(details: object, amount: number) that first uses the current strategy to validate the details and then, if valid, proceeds to execute the payment.
Client Code Simulation:
Show how a client can:
Create an instance of the PaymentProcessor.
Attempt to pay with a Credit Card using valid details.
Switch the strategy to PayPal at runtime.
Attempt to pay with PayPal using invalid details to show that the validation fails.